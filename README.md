# 동시성 처리

## 목차
1. 동시성 처리를 사용해하는 API
2. 동시성 처리가 필요한 이유
3. 기능별 동시성 처리 방법
4. 실제 코드 작성
<br />
<br />

---

## 1. 동시성 처리를 사용해하는 API

- 포인트 사용
- 포인트 충전
<br />
<br />

---

## 2. 동시성 처리가 필요한 이유

#### 1) 포인트 사용

- 사람의 금전적 자산을 다루기 때문에 무결성 보장이 필수
- 예상치 못한 과다 사용(잔액 초과 사용)을 막기 위해

#### 2) 포인트 충전
- 동시 다발적인 충전 요청에 대해 정확한 누적을 보장하기 위해

---
## 3. 기능별 동시성 처리 방법



| 기능 | 동시성 처리 방식 | 
| --- | --- |
| 포인트 사용 | 비관적 락 |
| 포인트 충전 | 낙관적 락 or 큐  

포인트 충전의 경우 비관적 락도 가능하다고 생각하지만, 
<br />성능 저하 우려로 낙관적 락이나 큐 처리를 통해 성능도 살리고 보안적인 부분에도 위험 가능성이 낮다고 판단


<br />

---


## 4. 실제 코드 작성

### 비관적 락

적용시키고 싶었으나, 메모리 기반 DB에서는 비관적 락을 구현할 수 없어 적용하지 못했다.


### 낙관적 락

충전 기능에 낙관적 락을 적용했다.
<br /> 
```
export class PointBody {
  @IsInt()
  amount: number;

  @IsInt()
  prevUpdateMillis: number;
}
```
클라이언트가 수정 요청 시점의 updateMillis 값을 함께 전달받는다.

```
// 낙관적 락 체크
    if (user.updateMillis !== pointDto.prevUpdateMillis) {
      throw new ConflictException(
        '다른 요청에 의해 이미 변경된 데이터입니다. 다시 시도해주세요.',
      );
    }
```

데이터 조회 시점의 updateMillis와 클라이언트가 보낸 prevUpdateMillis를 비교한다.
<br/> 값이 일치하면 요청을 허용하고, 다르면 동시성 충돌로 판단하여 에러를 반환한다.
